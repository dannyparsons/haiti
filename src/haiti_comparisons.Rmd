---
title: "Haiti Comparisons"
author: "Danny Parsons"
date: "11/06/2020"
output: 
  html_document:
    fig_width: 12
    fig_height: 6
---

```{r packages, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(here)
library(ggplot2)
library(lubridate)
library(reshape2)
library(viridis)
library(RColorBrewer)
library(tidyr)
library(hydroGOF)
library(stringr)
library(knitr)
library(kableExtra)
library(rnaturalearthdata)
library(rnaturalearth)
library(ggrepel)
library(sp)
library(tibble)
library(verification)
library(purrr)
library(dplyr)
library (ggspatial)
library(sf)
```

```{r setup, include=FALSE}
source(here("src", "helper_funs.R"))
zm <- readRDS(here("data", "daily_data_sorted1.RDS"))

zm <- zm$get_data_frame("merge")
zm <- dplyr::filter(zm, station != "thiotte")
zm$date <- as.Date(zm$date)

zm <- transmute(zm,
                station = station,
                latitde = latitude,
                longitude = longitude, 
                date = date, 
                year = year(date),
                month = month(date),
                day = day(date),
                rain = rain,
                chirps_rain = chirps_rain
)

if(anyDuplicated(zm %>% dplyr::select(station, date))) stop("Duplicates found!")

# 1 Jan = 1
s_doy_start <- 1
zm <- zm %>% mutate(doy = yday_366(date),
                    s_doy = (doy - s_doy_start + 1) %% 366,
                    s_doy = ifelse(s_doy == 0, 366, s_doy),
                    syear = ifelse(s_doy > (366 - s_doy_start + 1), year - 1, year),
                    month_abb = month(date, label = TRUE))
```

```{r monthly_zeros}
# Look at months with zero total rainfall and no missing values

zm_zero_months <- zm %>%
  group_by(station, month,year) %>%
  summarise(t_rain = sum(rain, na.rm = TRUE),
            n_na = sum(is.na(rain))) %>%
  filter(t_rain == 0 & n_na == 0)%>%

write.csv(here ("zero_months.csv"))
zm_month <- zm %>%
  group_by(station, year, month) %>%
  summarise(t_rain = sum(rain),
            n_na = sum(is.na(rain)))

zm_month_wide <- zm_month %>%
  pivot_wider(id_cols = c(year, month), names_from = station, values_from = t_rain)

zm <- zm %>%
  # Group by station and month for the calculation
  group_by(station, year, month) %>%
  # Add two columns for total monthly rainfall and number of missing values in the month
  mutate(t_rain = sum(rain, na.rm = TRUE), 
         # for each station and each month we calculate the total rain
         n_na = sum(is.na(rain)),
         # for each station and each month we calculate the number of missing values
         # Make rain_adj = NA if monthly total was 0 and there were no missing values
         # and otherwise rain_adj = rain
         # Some of these could be true zeros and could be checked later
         rain_adj = ifelse(t_rain == 0 & n_na == 0, NA, rain))

zm$rain <- zm$rain_adj
zm$rain_adj <- NULL
zm$t_rain <- NULL
zm$n_na <- NULL

zm <- zm %>%
  mutate(high_rain = rain > 200,
         rain = ifelse(high_rain, NA, rain),
         chirps_rain = ifelse(high_rain, NA, chirps_rain))
zm$high_rain <- NULL
```
``` {r quality control}

view (zm)


qc1 <- filter (zm, station == "quanaminthe", year %in% c(2019), month %in% c(1))
#there does not seem to be anything unusual about the high number of raindays in this period 
view (qc1)


```


```{r data_formats}
zm_long_st <- zm %>% 
  melt(id.vars = c("station", "date", "year", "syear", "month", "month_abb", 
                   "doy", "s_doy"),
       measure.vars = names(zm)[endsWith(names(zm), "rain")][-1],
       variable.name = "product", value.name = "pr_rain")
view(zm_long)

#the melt function takes data in a wide range of formats and stacks a set of columns into a single column of data

#creates a rainday column where the values are true or false depending on if there is rain that day or not
zm_long <- zm %>% 
  melt(id.vars = c("station", "date", "year", "syear", "month", "month_abb", "doy", "s_doy"),
       measure.vars = names(zm)[endsWith(names(zm), "rain")],
       variable.name = "product", value.name = "rain") %>%
  mutate(rainday = rain > 1)

zm_long$product <- recode(zm_long$product, rain = "station")
stations <- c( "cap_haitien", "quanaminthe", "jeremie", "damien", "petitionville", 
               "jacmel", "les_cayes") #north to south would be a better order for these 
products <- levels(zm_long$product)
products <- products[-1]
names(products) <- substr(products, 1, nchar(products) - 5)

metadata_station <- read.csv(here("data", "daily_metadata.csv"))

metadata_station$station <- factor(metadata_station$station, levels = stations) #making the 

zm_long$station <- factor(zm_long$station, levels = stations)

by_station <- zm_long %>%
  group_by(station) %>%
  filter(!is.na(rain)) %>%
  summarise(first_date = first(date), #this line of code seems to be giving the same last date for all our data 
            last_date = last(date))

metadata_station <- left_join(metadata_station, by_station, by = "station")
rm(by_station)

skable <- function(kable_input) {
  kable_input %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                                full_width = FALSE)
}
```

## Stations

- Mansa is the only station in the North. 
- It's results are different to the other three, which could be the location or the quality of the station
- Would be useful to have further stations in the North
- Station data filtered to start in 1979 (earliest product year)

```{r}
metadata_station %>% 
  dplyr::select(station, latitude, longitude) %>%   ##may have to add a min year/max year column
  kable(digits = 2) %>%
  skable()
```


```{r station_map, fig.width=9, fig.height=4.5}
hti_admbnda_adm0_cnigs_20181129 <- 
  sf::st_read(quiet=TRUE, 
              dsn = here("data", "hti_adm_cnigs_20181129",  
                         "hti_admbnda_adm0_cnigs_20181129.shp")) %>%
  dplyr::mutate(lon = purrr::map_dbl(geometry, ~sf::st_centroid(.x)[[1]]),
                lat = purrr::map_dbl(geometry, ~sf::st_centroid(.x)[[2]]))

locs <- read.csv(here("data", "daily_metadata.csv"))
width <- 0.05

ggplot2::ggplot() +
  ggplot2::geom_sf(data = hti_admbnda_adm0_cnigs_20181129, 
                   mapping=ggplot2::aes()) + 
  theme_grey() +
  geom_point(data = locs, aes(x = longitude, y = latitude), colour = "black") +
  
 geom_text_repel(data = locs, aes(x = var1, y = var2, label = station, fontface = "italic"), 
                 colour = "black", size = 3) 
```

```{r gof_fun}
dgof <- function(df, sim, obs, na.rm = TRUE) {
  g <- hydroGOF::gof(sim = df[[sim]], obs = df[[obs]], na.rm = na.rm) # how this function is working? 
  x <- as.list(g)
  names(x) <- row.names(g)
  x
}

comp_stats <- c("r", "ME", "PBIAS %", "MAE", "NSE", "rSD")
names(comp_stats) <- c("Correlation coefficient (1 = Perfect)",
                       "Mean bias (same units)",
                       "Percentage bias (%)",
                       "Mean absolute bias (same units)",
                       "Nash-Sutcliffe efficiency (1 = Perfect)",
                       "Ratio of standard deviations (< 1 less variable, > 1 more variable)")

comp_stats_digits <- c(2, 0, 0, 0, 2, 3)
```

## Yearly Comparisons 

```{r yearly_calcs}
quality_control <- zm_long %>% 
  group_by(syear,station,month) %>% 
  summarise(
    monthly_rain = sum(rain)
    
  )
view(zm_long)


by_syear <- zm_long %>%
  group_by(syear,station,product) %>%
  summarise(total_rain = sum(naif_nmin(rain, 330)),
            n_rain = sum(naif_nmin(rain, 330) > 0.1),
            max_rain = max(naif_nmin(rain, 330)),
            mean_rain = total_rain/n_rain,
            n_na = sum(is.na(rain))
)

by_syear_st <- by_syear %>% 
  pivot_wider(id_cols = c(station, syear),
              names_from = product, values_from = total_rain:n_na, names_sep = "__") 

gof_syear <- by_syear_st %>%  
  group_by(station) %>%
  nest() %>%
  mutate(n = purrr::map_int(data, 
                       ~sum(!is.na(.$total_rain__station) &
                              !is.na(.$total_rain__chirps_rain))), 
         #calculates number of complete years we have 
         gof__total_rain = purrr::map(data, dgof, "total_rain__chirps_rain", 
                                      "total_rain__station", 
                                      na.rm = TRUE),
         gof__n_rain = purrr::map(data, dgof, "n_rain__chirps_rain", "n_rain__station", 
                                  na.rm = TRUE),
         gof__mean_rain = purrr::map(data, dgof, "mean_rain__chirps_rain", 
                                     "mean_rain__station", 
                                     na.rm = TRUE) 
        
  )

gof_pr <- gof_syear %>% 
  unnest(cols = data)
```

## hurricane season comparisons 
```{r hurricane_season_calc}
zm_long_h <- filter(zm_long,month %in% c(6:11))

view (zm_long_h)

by_syear_h <- zm_long_h %>%
  group_by(syear,station,product) %>%
  summarise(total_rain = sum(naif_nmin(rain, 150)),    #since we are dealing with 6 month here instead of the full year i had to change from 330 to 150 
            n_rain = sum(naif_nmin(rain, 150) > 0.1),
            max_rain = max(naif_nmin(rain, 150)),
            mean_rain = total_rain/n_rain,
            n_na = sum(is.na(rain))
)

view (by_syear_h)

by_syear_st_h <- by_syear_h %>% 
  pivot_wider(id_cols = c(station, syear),
              names_from = product, values_from = total_rain:n_na, names_sep = "__") 

gof_syear_h <- by_syear_st_h %>%  
  group_by(station)%>%
  nest() %>%
  mutate(n = purrr::map_int(data, 
                       ~sum(!is.na(.$total_rain__station) &
                              !is.na(.$total_rain__chirps_rain))), 
         gof__total_rain = purrr::map(data, dgof, "total_rain__chirps_rain", 
                                      "total_rain__station", 
                                      na.rm = TRUE),
         gof__n_rain = purrr::map(data, dgof, "n_rain__chirps_rain", "n_rain__station", 
                                  na.rm = TRUE),
         gof__mean_rain = purrr::map(data, dgof, "mean_rain__chirps_rain", 
                                     "mean_rain__station", 
                                     na.rm = TRUE) 
        
  )

gof_pr_h <- gof_syear_h %>% 
  unnest(cols = data)




```




```{r yearly_plots_fun}
yearly_plots <- function(df, gof_col, stat_pr, stat_st) {
  max_y <- max(c(df[[stat_pr]], df[[stat_st]]), na.rm = TRUE)
  dat <- df %>% 
    pivot_longer(cols = c(stat_pr, stat_st), names_to = "product", values_to = stat_pr) %>%
    mutate(ME = purrr::map_dbl(.data[[gof_col]], "ME"),
           r = purrr::map_dbl(.data[[gof_col]], "r"),
           rSD = purrr::map_dbl(.data[[gof_col]], "rSD")
           )
  mean_df <- dat %>% 
    group_by(station, product) %>% 
    summarise(m = mean(.data[[stat_pr]], na.rm = TRUE))
  g <- ggplot(dat, aes(x = syear, y = .data[[stat_pr]], colour = product)) +
    geom_line() +
    geom_point() +
    geom_hline(data = mean_df, aes(yintercept = m, colour = product)) +
    scale_x_continuous(limits = c(1979, 2012)) +
    # n
    geom_text(data = dat, aes(label = paste("n", n)), size = 4,
              x = 1979, y = max_y, na.rm = TRUE, 
              inherit.aes = FALSE) +
    # bias
    geom_text(data = dat, aes(label = paste("bias", signif(ME, 2))), 
              size = 4, x = 1979 + 6, y = max_y, na.rm = TRUE, 
              inherit.aes = FALSE) +
    # cor
    geom_text(aes(label = paste("cor", round(r, 2))), 
              size = 4, x = 1979 + 14, y = max_y, na.rm = TRUE, 
              inherit.aes = FALSE) +
    # rSD
    geom_text(aes(label = paste("rSD", round(rSD, 2))), 
              size = 4, x = 1979 + 22, y = max_y, na.rm = TRUE, 
              inherit.aes = FALSE) +
    ggtitle(paste(stat_pr, ":", "CHIRPS", "vs", "station")) +
    facet_wrap(~station)
  g
}
```

```{r stats_tables_fun}
stats_tables <- function(df, obj_col, obj_stats = comp_stats, name) {
  dat <- df %>% 
    ungroup()
  for (i in seq_along(obj_stats)) {
    dat <- dat %>%
      mutate(purrr::map_dbl(df[[obj_col]], obj_stats[i]))
    names(dat)[ncol(dat)] <- obj_stats[i]
  }
  dat <- dat %>% 
    mutate(station = as.character(station))
  dat <- dat[ , c("station", obj_stats)]
  dat %>%
  kable(digits = comp_stats_digits[i], caption = paste("Comparison statistics:", name), 
        format.args = list(big.mark = ",")) %>%
  skable() %>%
  print()
}
```

### Comparison Statistics for Total Yearly Rainfall

- Correlation between the station and chirps value goes from a (absolute) low of 0.01 for petitionville to a high  of 0.67 for les cayes.We can see that correlation is on the Low side for most stations. This likely means that we would have difficulty using the chirps as a predictor 
-The (absolute) bias is quite low for the stations cap Haitian , Quanaminthe, Jeremie and Petitionville with all of them within a 100. It is highest for les cayes which has a bias of -680. We might be able to use the chirps data with the stations that have a lower bias to get an idea of how much rainfall there is. 
-It is worth  noting that Jacmel has 38 years of comparison and Jeremie has only 18 with the rest of the stations distributed between those 2 values. 
-

```{r yearly_total_plots}
yearly_plots(gof_pr, gof_col = "gof__total_rain", 
                        stat_pr = "total_rain__chirps_rain", 
                        stat_st = "total_rain__station")

ggsave(here("results", "syear_total_rain.png"), width = 12, height = 6)

```


```{r yearly_n_obs, results="asis"}
gof_syear %>% 
  dplyr::select(station, n) %>%
  kable(caption = "Number of years compared") %>%
  skable()
```

```{r yearly_total_rain_tables, results="asis"}
stats_tables(gof_syear, "gof__total_rain", name = "Total Yearly Rainfall")
```


### Comparison Statistics for Number of rainy days

-Correlation on the whole is very low between chirps and station values across all the stations 
-The bias is quite low for the same sort of stations when we looked at total rainfall (cap Haitian,Quanaminthe,Jeremie,Damien,Petitionille)
-One anomalous result that requires further inspection is the very high number of rain days that we have for les cayes in the years 1995-2000. A further inspection of those values is needed. 
```{r yearly_n_rain_plots}

yearly_plots(gof_pr, gof_col = "gof__n_rain", 
             
                        stat_pr = "n_rain__chirps_rain", 
                        stat_st = "n_rain__station")

ggsave(here("results", "syear_n_rain.png"), width = 12, height = 6)

#want to change the y axis to read n_rain instead of chirps
```

```{r yearly_n_rain_tables, results="asis"}

view(gof_syear)
stats_tables(gof_syear, "gof__n_rain", name = "number of rain days ")
```

## hurricane season comparisons (total rainfall)
``` {r hurricane_season_plots}

yearly_plots(gof_pr_h, gof_col = "gof__total_rain", 
                        stat_pr = "total_rain__chirps_rain", 
                        stat_st = "total_rain__station")

ggsave(here("results", "syear_total_rain_h.png"), width = 12, height = 6)


```


```{r yearly_total_rain_tables, results="asis"}
stats_tables(gof_syear_h, "gof__total_rain", name = "Total Yearly Rainfall")
```

``` {r hurricane_season_n_rain_plots }

yearly_plots(gof_pr_h, gof_col = "gof__n_rain", 
             
                        stat_pr = "n_rain__chirps_rain", 
                        stat_st = "n_rain__station")

ggsave(here("results", "syear_n_rain_h.png"), width = 12, height = 6)


```

```{r yearly_n_rain_tables, results="asis"}

stats_tables(gof_syear_h, "gof__n_rain", name = "number of rain days ")
```

## Monthly Comparisons

```{r monthly_calcs}
by_month <- zm_long %>%
  group_by(station, syear, month_abb, product) %>%
  #filter(month %in% c(11:12, 1:4)) %>%
  summarise(total_rain = sum(naif_nmin(rain, 25)),  
            n_rain = sum(naif_nmin(rain, 25) > 0.1),  
            max_rain = max(naif_nmin(rain, 20)), 
            mean_rain = ifelse(n_rain == 0, NA, total_rain/n_rain), 
            n_na = sum(is.na(rain))
            )

by_month_st <- by_month %>%
  pivot_wider(id_cols = c(station, syear, month_abb), 
              names_from = product, values_from = total_rain:mean_rain, names_sep = "__") 


gof_month <- by_month_st %>%
  group_by(station) %>%
  nest() %>%
  mutate(n = purrr::map_int(data, 
                        ~sum(!is.na(.$total_rain__station) & 
                               !is.na(.$total_rain__chirps_rain))),
         gof__total_rain = purrr::map(data, dgof, "total_rain__chirps_rain", 
                                      "total_rain__station", 
                                      na.rm = TRUE),
         gof__n_rain = purrr::map(data, dgof, "n_rain__chirps_rain", "n_rain__station", 
                                  na.rm = TRUE),
         gof__mean_rain = purrr::map(data, dgof, "mean_rain__chirps_rain", 
                                     "mean_rain__station", 
                                      na.rm = TRUE)
         
         )


gof_pr_month <- gof_month %>%
  unnest(cols = data)
```

```{r monthly_plots_fun}
monthly_plots <- function(df, stat_pr,gof_col, stat_st, product_name) {
  max_y <- max(c(df[[stat_pr]], df[[stat_st]]), na.rm = TRUE)
  vals_relace <- c(product_name, "station")
  names(vals_relace) <- c(stat_pr, stat_st)
  dat <- df %>% 
    filter(month_abb %in% month.abb[c(1:12)]) %>%
    pivot_longer(cols = c(stat_pr, stat_st), names_to = "product", values_to = stat_pr) %>%
    mutate(product = recode(product, !!!vals_relace),
           ME = purrr::map_dbl(.data[[gof_col]], "ME"),
           r = purrr::map_dbl(.data[[gof_col]], "r"),
           rSD = purrr::map_dbl(.data[[gof_col]], "rSD"))
  mean_df <- dat %>% 
    group_by(station, product, month_abb) %>% 
    summarise(m = mean(.data[[stat_pr]], na.rm = TRUE))

  g <- ggplot(dat, aes(x = syear, y = .data[[stat_pr]], colour = product)) +
    geom_line() +
    geom_point() +
    geom_hline(data = mean_df, aes(yintercept = m, colour = product)) +
    scale_x_continuous(limits = c(1979, 2012)) +
    ggtitle(paste(stat_pr, ":", product_name, "vs", "station")) +
    facet_wrap(~month_abb) +
     # n
    geom_text(data = dat, aes(label = paste("n", n, sep = "  ")), size = 4,
              x = 1979, y = max_y, na.rm = TRUE, 
              inherit.aes = FALSE)  +
    
    # bias
    geom_text(data = dat, aes(label = paste("bias", signif(ME, 2), sep = "  ")), 
              size = 4, x = 1979 + 6, y = max_y, na.rm = TRUE, 
              inherit.aes = FALSE) +
    # cor
    geom_text(aes(label = paste("cor", round(r, 2), sep = "  ")), 
              size = 4, x = 1979 + 14, y = max_y, na.rm = TRUE, 
              inherit.aes = FALSE)  +
    # rSD
    geom_text(aes(label = paste("rSD", round(rSD, 2), sep = "  ")), 
              size = 4, x = 1979 + 22, y = max_y, na.rm = TRUE, 
              inherit.aes = FALSE) 
    
    
  g
}

view (gof_pr_month)
```

### Comparison statistics for total monthly rainfall
-For Cap Haitian , on the whole the bias is quite low with peaks in January and may 
-Damien also has low biases except for March , April and Oct
-The biases in Jacmel tend to be higher between the months of April and November 
-Biases in Jeremie are on the low side, except for the month March
-Les cayes has very little rainfall between December and April so or chirps data is always overestimating, biases on the whole are quite low and there are no immediate outliers. 
-For petitionville we have very little station rain between December and march, October 2003/2004 seems to have an outlying value of total rain
-For quanaminthe, the biases are in general quite low with slightly larger ones for May. We have some outlying station values , most notably Jan 2008/2009 and Nov 2012/2013 where the station value seems very out of line with the chirps estimate


```{r monthly_plots_total_rain}
for (i in seq_along(stations)) {
  s <- stations[i]
  monthly_plots(gof_pr_month %>% filter(station == s),
                stat_pr = "total_rain__chirps_rain", gof_col = "gof__total_rain",
                stat_st = "total_rain__station", product_name = "CHIRPS")
  ggsave(here("results", paste0("month_total_rain_", s, ".png")), width = 12, height = 6)
}
```

```{r monthly_tables_total_rain, results="asis"}
stats_tables(gof_month, "gof__total_rain", name = "total_rain_stats")
```

### Comparison statistics for number of monthly raindays
-For Cap Haitian the bias is quite low between December and April, it is quite a bit larger during the remaining months and especially during July , August and November. 
-For Damien, the bias is fairly low between October and February where it starts to increase. The months July and April have particularly high biases. 
- For Jacmel we get that the bias is particularly high for the months March, April and May.
-For jeremie the bias is generally low with perhaps the exception of August where is is a bit higher than other places.
-Les cayes has a small amount of (chirps) raindays between Dec and April and this leads to high biases in those months.The highest biases are in the months April and May. 
-For petitionville, the biases vary considerably and none of them are clear outliers. Around may 1993 we see that it rained every day of the month for this station and that stands out a bit so perhaps further inspection of that would be a good idea.
-The biases for quanaminthe tend to be considerable higher in the months July and August. 

```{r monthly_plots_n_rain}

for (i in seq_along(stations)) {
  s <- stations[i]

monthly_plots(gof_pr_month %>% filter(station == s), gof_col = "gof__n_rain",
                        stat_pr = "n_rain__chirps_rain", 
                        stat_st = "n_rain__station", product_name = "CHIRPS")  

ggsave(here("results", paste0("smonth_n_rain", s, ".png")), width = 12, height = 6)
}

```

```{r monthly_tables_n_rain, results="asis"}
stats_tables(gof_month, "gof__n_rain", name = "n_rain_stats_month")
```
## Markov Chain models of the chance of rain

- All the stations have a model for rain that is roughly the same so that the peaks and troughs occur at the same point in the year.
- While the station rain is predicted to have two peaks, the chirps model looks like it has one peak in Aug-Sep. 
- For most stations the probabilities tend to be closer for the months Oct-Dec
-Threshold 5 seems to improve the fit to the station for Quanaminthe and Cap Haitian however it does not make much of a difference to the remaining stations. 
-

```{r markov_chain_setup}
view(zm_long)
view (zm_long_st)
zambia_markov <- zm %>% 
  filter(!is.na(chirps_rain) & !is.na(rain)) %>%
  mutate(rainday1 = rain > 0.85,
         pr_rainday1 = chirps_rain > 0.85,
         pr_rainday2 = chirps_rain > 2,
         pr_rainday3 = chirps_rain > 3,
         pr_rainday4 = chirps_rain > 4,
         pr_rainday5 = chirps_rain > 5)

f_zero_order_station <- rainday1 ~ (cos(s_doy * 1 * 2 * pi/366) +
                                    sin(s_doy * 1 * 2 * pi/366) + 
                                    cos(s_doy * 2 * 2 * pi/366) + 
                                    sin(s_doy * 2 * 2 * pi/366) +
                                    cos(s_doy * 3 * 2 * pi/366) +
                                    sin(s_doy * 3 * 2 * pi/366))
f_zero_order_product <- update.formula(f_zero_order_station, pr_rainday1 ~ .)

predict_stack_lst <- list()

for(s in seq_along(stations)) {  
  predict_df <- data.frame(station = stations[s], s_doy = 1:366,
                           s_doy_date = as.Date(1:366, origin = as.Date("1999/12/31")))
  dat <- zambia_markov %>%
    filter(station == stations[s])

  zero_order_station <- glm(f_zero_order_station, data = dat, family = binomial)
  zero_order_product <- glm(f_zero_order_product, data = dat, family = binomial)
  #print(anova(zero_order_station, test="Chisq"))
  predict_df[["station_fit"]] <- predict(zero_order_station, newdata = predict_df,
                                         type = "response")
  predict_df[["chirps_fit"]] <- predict(zero_order_product, newdata = predict_df,
                                        type = "response")
  
  f_zero_order_product_2thres <- update.formula(f_zero_order_station, pr_rainday2 ~ .)
  f_zero_order_product_3thres <- update.formula(f_zero_order_station, pr_rainday3 ~ .)
  f_zero_order_product_4thres <- update.formula(f_zero_order_station, pr_rainday4 ~ .)
  f_zero_order_product_5thres <- update.formula(f_zero_order_station, pr_rainday5 ~ .)
  fms_thres <- list(f_zero_order_product_2thres, f_zero_order_product_3thres,
                    f_zero_order_product_4thres, f_zero_order_product_5thres)
  for(j in seq_along(fms_thres)) {
    zero_order <- glm(fms_thres[[j]], data = dat, family = binomial)
    predict_df[[paste0("chirps", "_", j + 1, "thres")]] <- predict(zero_order,
                                                                   newdata = predict_df,
                                                                   type = "response")
  }

  predict_stack <- predict_df %>% melt(id.vars = c("station", "s_doy", "s_doy_date"), 
                                       variable.name = "product", value.name = "prob")

  predict_stack$product <- as.character(predict_stack$product)
  predict_stack_lst[[length(predict_stack_lst) + 1]] <- predict_stack
  # Plot small amounts
  # g <- ggplot(predict_stack, aes(x = s_doy, y = prob, colour = type)) +
  #   geom_line() +
  #   facet_wrap(~product2) +
  #   scale_color_manual(values = c("black", c25[1:7])) +
  #   ggtitle(paste("Chance of rain:", stations[s]))
  # ggsave(here("results", "zambia", paste0("zambia_", "markov_zero", stations[s], ".png")), 
  #        plot = g, width = 12, height = 6)
}
predict_stack_all <- bind_rows(predict_stack_lst)
predict_stack_all$product <- factor(predict_stack_all$product)
predict_stack_all$product <- relevel(predict_stack_all$product, "station_fit")
```

```{r markov_chain_plots}
  dat <- predict_stack_all %>% filter(product %in% c("station_fit", "chirps_fit"))
  g <- ggplot(dat, aes(x = s_doy_date, y = prob, colour = product, size = product)) +
    geom_line() +
    facet_wrap(~station) +
    scale_size_manual(values = c(0.8, rep(0.6, 4))) +
    scale_color_manual(values = c("black", c25[1:4])) +
    scale_x_date(date_breaks = "2 months", date_labels = "%b") +
    ggtitle(paste("Chance of rain"))
  print(g)
  ggsave(here("results", paste0("markov_zero.png")),
         plot = g, width = 12, height = 6)
```

```{r markov_chain_plots_thresh}
  dat <- predict_stack_all
  g <- ggplot(dat, aes(x = s_doy_date, y = prob, colour = product, size = product)) +
    geom_line() +
    facet_wrap(~station) +
    scale_size_manual(values = c(0.8, rep(0.6, 5))) +
    scale_color_manual(values = c("black", c25[1:5])) +
    scale_x_date(date_breaks = "2 months", date_labels = "%b") +
    ggtitle(paste("Chance of rain"))
  print(g)
  ggsave(here("results", paste0("markov_zero_threshs.png")),
         plot = g, width = 12, height = 6)
```

### Distribution of rainfall amounts

```{r}
for(i in c(50, 10, 5)) {
g <- ggplot(zm_long %>% filter(rain > 0.85), aes(x = rain, colour = product)) +
  stat_ecdf(aes(size = product), pad = FALSE, geom = "step") +
  coord_cartesian(xlim = c(NA, i)) +
  scale_color_manual(values = c("black", c25[1:length(products)])) +
  scale_size_manual(values = c(1, rep(0.5, length(products)))) +
  facet_wrap(~station)
print(g)
}
```

```{r}
for(i in c(200, 50, 10, 5, 2, 1)) {
  g <- ggplot(zm_long %>% filter(rain > 0), 
              aes(x = rain, y = after_stat(density), colour = product)) +
    geom_freqpoly(aes(size = product), binwidth = 0.5, centre = 0.5) +
    scale_color_manual(values = c("black", c25[1:length(products)])) +
    scale_size_manual(values = c(1, rep(0.5, length(products)))) +
    scale_x_continuous(limits = c(0, NA)) +
    coord_cartesian(xlim = c(NA, i)) +
    facet_wrap(~station)
  print(g)
}
```

```{r}
prop_amounts <- zm_long %>%
  filter(rain > 0.85 & station == "Livingstone") %>%
  mutate(rain_grps = cut(rain,
                          breaks = c(0, 0.85, 1.1, 2.1, 3.1, 4.1, 5.1, 10, 20, 30, 50, 200),
                          include.lowest = TRUE)) %>%
  group_by(product, rain_grps) %>%
  summarise(n = n()) %>%
  mutate(prop = n/sum(n), cumul = cumsum(prop))

ggplot(prop_amounts, aes(x = rain_grps, y = prop, fill = product)) +
  geom_col(position = "dodge")

prop_amounts %>%
  pivot_wider(names_from = product, values_from = cumul, id_cols = rain_grps) %>%
  kable(digits = 2) %>%
  skable()
```

### Detection of rainfall on the same days (November to April)

![](cont_table.jpg)

- In general these results confirm what was seen above
- 75% accuracy for all products apart from ERA5 (66%)
- High bias for all products, as already known (more rainy days estimated than observed)
- High hit rate and false alarm ratios, which is expected because of high bias
- All apart from ERA5 perform well on threat score, which only considers how well it estimates rainy days
- Proportion of misses is reassuringly low across products
- Performance will change if different thresholds are introduced

```{r raindays_verify}

view(zm)

raindays <- zm %>% 
  mutate(st_rainday0p85 = rain > 0.85,
         pr_rainday0p85 = chirps_rain > 0.85,
         pr_rainday3 = chirps_rain > 3,
         pr_rainday5 = chirps_rain > 5)

sverify <- function(df, obs, pred) {
  v <- verification::verify(obs = df[[obs]], pred = df[[pred]], 
                       obs.type = "binary", frcst.type = "binary")
  class(v) <- "list"
  v
}

by_st_pr <- raindays %>%
  group_by(station) %>% #removed product
  nest() %>%
  mutate(v = purrr::map(data, sverify, obs = "st_rainday0p85", pred = "pr_rainday0p85"),  #column product not found
         bias = purrr::map_dbl(v, "BIAS"))
```

```{r cont_tables, results="asis"}
cont_tables <- function(df, name) {
  df %>%
    kable(caption = name, digits = 2, format.args = list(big.mark = ",")) %>%
    skable() %>%
    row_spec(nrow(df), bold = TRUE)
}

rain_levs <- c("rain", "no_rain")
ver_zm <- raindays %>%
  group_by(station) %>% #removed product
  filter(month %in% c(11:12, 1:4)) %>%
  filter(!is.na(st_rainday0p85) & !is.na(pr_rainday0p85)) %>%
  summarise(hit = sum(st_rainday0p85 & pr_rainday0p85),
            fa = sum(!st_rainday0p85 & pr_rainday0p85),
            miss = sum(st_rainday0p85 & !pr_rainday0p85),
            cneg = sum(!st_rainday0p85 & !pr_rainday0p85),
            n = n(),
            accuracy = (hit + cneg)/n,
            bias = (hit + fa)/(hit + miss),
            hit_rate = hit/(hit + miss),
            far = fa/(hit + fa),
            ts = hit/(hit + miss + fa),
            ets = verification::verify(obs = st_rainday0p85, pred = pr_rainday0p85, 
                                       obs.type = "binary", frcst.type = "binary")$ETS,
            miss_frac = miss/n,
            hk = (hit/(hit + miss) - (fa/(fa + cneg))),
            hss = verification::verify(obs = st_rainday0p85, pred = pr_rainday0p85, 
                                       obs.type = "binary", frcst.type = "binary")$HSS
            ) %>%
  arrange( station) #removed product

measures <- c("accuracy", "bias", "hit_rate", "far", "ts", "ets", "miss_frac", "hk", "hss")
names(measures) <- c("Accuracy: What fraction of the estimates were correct?
                     (hits + correct negative)/total (1 = perfect)",
                     "Bias: Ratio of number of rain days from estimate over number of rain days from station. 
                     (hits + false alarms)/(hits + misses) (1 = perfect)",
                     "Hit rate (probability of detection) What fraction of the station rain days were correctly estimated? hits/(hits + misses) (1 = perfect)",
                     "False alarm ratio: What fraction of the estimated rain days actually did not rain? false alarms/(hits + false alarms)",
                     "Threat score: How well did the estimate rain days correspond to the observed rain days?",
                     "Equitable threat score: How well did the estimate rain days correspond to the station rain days (accounting for hits due to chance)?",
                     "Proportion of misses: How many rain days in the station were not detected by the estimate?",
                     "Hanssen and Kuipers discriminant: How well did the forecast separate the rainy days from the dry days? Uses all elements in the contingency table.",
                     "Heidke skill score: What was the accuracy of the forecast relative to that of random chance? Measures the fraction of correct estimates after eliminating those estimates which would be correct due purely to random chance."
                     )
for(i in seq(measures)) {
  df <- ver_zm %>% 
    select(station, measures[[i]]) %>% #removed product
    pivot_wider(id_cols = station, names_from = product, values_from = measures[[i]])
  names(df)[endsWith(names(df), "rain")] <- substr(names(df)[endsWith(names(df), "rain")],
                                                   1, 
                                                   nchar(names(df)
                                                         [endsWith(names(df), "rain")]
                                                         ) 
                                                   - 5)
  df[nrow(df) + 1, ] <- c(list("(All)"), as.list(as.numeric(colMeans(df[ , -1]))))
  print(cont_tables(df, names(measures)[i]))
  
}
```

